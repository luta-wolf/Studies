# Числовые типы
# Первая категория типов данных: числовые типы и операции над ними
a = 5
b = 5.5
print(type(a))
print(dir(a))
print(type(b))
print(dir(b))
print('-' * 20)
print(40 + 3.14)# Преобразование целого в число с плавающей точкой
                 # математика и результат с плавающей точкой
# Вызывая встроенные функции, типы можно преобразовывать вручную:
print(int(3.1415)) # Сокращает число с плавающей точкой до целого
print(float(3))    # Преобразует целое число в число с плавающей точкой
a = 3 # Имя создается: не объявляется заранее
b = 4
print(a + 1, a - 1) # Сложение (3 + 1) , вычитание (3-1)
print(b * 3, b / 2) # Умножение (4 * 3), деление (4/2)
print(a % 2, b ** 2) # Деление по модулю (нахождение остатка),возведение в степень (4 ** 2)
print(2 + 4.0, 2.0 ** b) # Преобразования разнородных типов
print(b / 2 + a)    # То же, что и ((4/2) + 3)
print(b // 2 + a)
print(b / (2.0 + a))  # То же, что и (4 / (2.0 + 3))
print('-' * 20)
# Форматы числового отображения
num = 1 / 3.0
print(num) # Явный вывод
print('%e' % num) # Выражение форматирования строк
print('%4.2f' % num)
print('%4.4f' % num) # Альтернативный формат с плавающей точкой
print('{0:4.2f}'.format(num)) # Метод форматирования строк
# Форматы отображения str и герг
print(repr('spam')) # Используется интерактивным выводом: форма как в коде
print(str('spam'))  # Используется print: форма , дружественная к пользователю
print('-' * 20)
# Сравнения: нормальные и сцепленные
print(1 < 2)    # Меньше
print(2.0 >= 1) # Больше или равно: число разнородного типа 1 преобразуется в 1.0
print(2.0 == 2.0) # Равенство значений
print(2.0 != 2.0) # Неравенство значений
X = 2
Y = 4
Z = 6
print(X < Y < Z)  # Сцепленные сравнения: проверки вхождения в диапазон
print(X < Y and Y < Z)
# разрешено выстраивать цепочки произвольной длины:
print(X < Y > Z)
print(X < Y and  Y > Z)
print(1 < 2 < 3.0 < 4)
print(1 > 2 > 3.0 > 4)
#В сцепленных проверках можно использовать другие сравнения
print(1 == 2 < 3) # То же, что и 1 == 2 and 2 < 3
                  # Не то же, что и False < 3 (эквивалентно 0 < 3, которое истинно!)
print(1.1 + 2.2 == 3.3) # Разве это не должно быть True?
print(1.1 + 2.2)
print(int(1.1 + 2.2) == int(3.3))  # Нормально в случае преобразования
print('-' * 20)
#Деление: классическое, с округлением в меньшую сторону и настоящее
print(10 / 4)   # сохраняет остаток
print(10 / 4.0) # сохраняет остаток
print(10 // 4)  # усекает остаток
print(10 // 4.0) # округляет в меньшую сторону
print('-' * 20)
# Округление в меньшую сторону или усечение
import math
print(math.floor(2.5)) # Ближайшее меньшее значение
print(math.floor(-2.5))
print(math.trunc(2.5))  # Усечение дробной части (в сторону нуля)
print(math.trunc(-2.5))
print(5 / 2, 5 / -2)   # Усекает в меньшую сторону: округляет до первого меньшего целого
print(5 // 2, 5 // -2)  # 2.5 становится 2, -2.5 становится -3
print(5 / 2.0, 5 / -2.0)  # Повторяется для чисел с плавающей точкой,
print(5 // 2.0, 5 // -2.0)  # хотя результат имеет тот же тип
print('-' * 20)
#Точность целых чисел
print(999999999999999999999999999999 +1)
print(2 ** 200)
#Комплексные числа
print(1j * 1J)
print(2 + 1j * 3)
print((2 + 1j) * 3)
print(type(1j + 1J))
print('-' * 20)
#Шестнадцатеричная, восьмеричная и двоичная формы записи: литералы и преобразования
print(0o1, 0o20, 0o377) # Восьмеричные литералы: основание 8, цифры 0-7
print(0x01, 0x10, 0xFF) # Шестнадцатеричные литералы: основание 16, цифры 0-9/A-F
print(0b1, 0b10000, 0b11111111) # Двоичные литералы: основание 2, цифры 0~1 (З.Х, 2.6+)
print(0xff, 15*16**1 + 15*16**0)
print(0x2f, 2*16**1 + 15*16**0)
print(0xaa, 10*16**1 + 10*16**0)
print(0xf, 0b1111, 1*2**3 + 1*2**2 + 1*2**1 + 1*2**0)
print(oct(64)) # oct преобразует десятичное число в восьмеричное
print(hex(64)) # hex — в шестнадцатеричное
print(bin(64)) # bin — в двоичное
print(64, 0o100, 0x40, 0b1000000) # Цифры -> числа в сценариях и строки
print(int('64'), int('100', 8), int('40', 16), int('1000000', 2))
print(int('0x40', 16), int('0b1000000', 2)) # Литеральные формы также поддерживаются
# Функция eval(),  трактует строки, как если бы они были кодом Python
print(eval('64'), eval('0o100'), eval('0x40'), eval('0b1000000'))
print('%o, %x, %x, %X' % (64, 64, 255, 255)) # Числа => цифры
X = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF
print(X)
print(oct(X))
print(bin(X))
print('-' * 20)

# Побитовые операции
x = 1 # Десятичное значение 1 в битах выглядит как 0001
print(x << 1)  # Сдвиг влево на 1 бита: 0010
print(x << 2)  # Сдвиг влево на 2 бита: 0100
print(x << 3)  # Сдвиг влево на 3 бита: 0100
print(x << 4)  # Сдвиг влево на 4 бита: 1000
#  двоичное “ИЛИ” для объединения битов
print(x | 1)   # (0001 | 0001 = 0001)
print(x | 2)   # Побитовое ИЛИ (один из битов = 1) : 0011 (0001 | 0010 = 0011)
print(x | 3)   # (0001 | 0011 = 0011)
print(x | 4)   # (0001 | 0100 = 0101)
print(x | 5)   # (0001 | 0101 = 0101)
# двоичное “И” для выбора общих битов
print(x & 1)   # Побитовое И (оба бита = 1) : 0001 (0001 & 0001 = 0001)
print(x & 2)   # (0001 & 0010 = 0000)
X = 0b0001 # Двоичные литералы
print(X << 2) # Сдвиг влево
print(bin(X << 2)) # Строка двоичных цифр
print(bin(X | 0b010)) # Побитовое ИЛИ: один из битов = 1
print(bin(X & 0b1)) # Побитовое И: оба бита = 1
X = 0xFF # Шестнадцатеричные литералы
print(bin(X))
print(X ^ 0b10101010)  # Побитовое исключающее ИЛИ: один из битов = 1, но не оба
print(bin(X ^ 0b10101010))
print(int('01010101', 2)) # Цифры => число: строка в целое по указанному основанию
print(hex(85)) # Число => цифры: строка шестнадцатеричных цифр
# bit_length() - позволяет запрашивать количество битов, требующееся для
# представления величины числа в двоичном виде.
X = 99
print(bin(X), X.bit_length(), len(bin(X)) - 2)
print(bin(256), (256).bit_length(), len(bin(256)) - 2)
print('-' * 20)

# Другие встроенные инструменты для обработки чисел
import math
print(math.pi, math.e) # Общие константы
print(math.sin(2 * math.pi / 180)) # Синус, тангенс, косинус
print(math.sqrt(144), math.sqrt(2)) # Квадратный корень
print(pow(2, 4), 2 ** 4, 2.0 ** 4.0) # Возведение в степень
print(abs(-42.0), sum((1, 2, 3, 4))) # Абсолютное значение, суммирование
print(min((3, 1, 2, 4)), max((3, 1, 2, 4))) # Минимум, максимум
print(math.floor(2.567), math.floor(-2.567)) # Округление в меньшую сторону
                                             # (до меньшего целого)
print(math.trunc(2.567), math.trunc(-2.567)) # Усечение (отбрасывание
                                             # десятичных цифр)
print(int(2.567), int(-2.567)) # Усечение (преобразование в целое число)
print(round(2.567), round(2.467), round(2.567, 2)) # Округление
print('%.1f' % 2.567, '{0:.01f}'.format(2.567)) # Округление для отображения 1 цифра
print('%.2f' % 2.567, '{0:.02f}'.format(2.567)) # Округление для отображения 2 цифра
print('%.3f' % 2.567, '{0:.03f}'.format(2.567)) # Округление для отображения 3 цифра
print(1 / 3.0, round(1 / 3.0, 2), '%.2f' % (1 / 3.0))
print(type(1 / 3.0), type(round(1 / 3.0, 2)), type('%.2f' % (1 / 3.0)))
# 3 способа извлечение квадратного корня
import math
print(math.sqrt(144)) # Функция из модуля
print(144 ** 0.5)     # Выражение
print(pow(144, 0.5))  # Встроенная функция
print(math.sqrt(1234567890)) # Более крупные числа
print(1234567890 ** 0.5)
print(pow(1234567890, 0.5))
print('-' * 20)
import random
print(random.random()) # Случайные числа с плавающей точкой, целые, выбор, тасование
print(random.randint(1, 10))
print(random.choice(['Denis Skrynnikov', 'Olga Skrynnikova', 'Victor Skrynnikov']))
suits = ['hearts', 'clubs', 'diamonds', 'spades']
random.shuffle(suits)
print(suits)
print('-' * 20)

# Другие числовые типы
# Десятичные типы
print(0.1 + 0.1 + 0.1 - 0.3) # Результат близок к нулю, но здесь недостаточно битов,
                             # чтобы обеспечить точность
print(round(0.1 + 0.1 + 0.1 - 0.3, 2))
from decimal import Decimal
print(Decimal('0.1') + Decimal('0.1') + Decimal('0.1') - Decimal('0.3'))
print(Decimal(0.1) + Decimal(0.1) + Decimal(0.1) - Decimal(0.3))
# Когда десятичные объекты с разной точностью смешиваются в выражениях,
# Python автоматически выполняет преобразование к наибольшему количеству
# десятичных цифр после точки:
print(Decimal('0.1') + Decimal('0.10') + Decimal('0.10') - Decimal('0.30'))
import decimal
print(decimal.Decimal(1) / decimal.Decimal(7)) # По умолчанию: 28 цифр
decimal.getcontext().prec = 4 # Устанавливаем точность в 4 знака после точки
print(decimal.Decimal(1) / decimal.Decimal(7)) # Фиксированная точность
print(Decimal(0.1) + Decimal(0.1) + Decimal(0.1) - Decimal(0.3))
pay = 1999 + 1.33
print(pay, type(pay))
decimal.getcontext().prec = 2
pay = decimal.Decimal(str(1999 + 1.33))
print(pay, type(pay))
decimal.getcontext().prec = 28
# Диспетчер контекста для десятичных чисел
# Когда происходит выход из оператора with, точность сбрасывается в свое первоначальное состояние.
print(decimal.Decimal('1') / decimal.Decimal('3'))
with decimal.localcontext() as ctx:
    ctx.prec = 2
    print(decimal.Decimal('1') / decimal.Decimal('3'))
print(decimal.Decimal('1') / decimal.Decimal('3'))
print('-' * 20)
# Дробный тип
from fractions import Fraction
x = Fraction(1, 3) # Числитель, знаменатель
y = Fraction(4, 6) # Упрощается до 2, 3 по наибольшему общему делителю
print(x, y)
print(x + y)
print(x - y) # Результаты точны: числитель, знаменатель
print(x * y)
print(Fraction(0.25))
print(Fraction(1.25))
print(Fraction(0.25) + Fraction(1.25))
a = 1 / 3.0
b = 4 / 6.0
print(a) # Результат точен лишь настолько,насколько позволяют аппаратные средств
print(b)  # Точность может теряться из-за множества вычислений
print(a + b)
print(a - b)
print(a * b)
print(0.1 + 0.1 + 0.1 - 0.3) # Должен быть нулем (близко, но не точно)
from fractions import Fraction
print(Fraction(1,10) + Fraction(1,10) + Fraction(1,10) - Fraction(3,10)) # нуль
from decimal import Decimal
print(Decimal('0.1') + Decimal('0.1') + Decimal('0.1') - Decimal('0.3')) # нуль
print(1 / 3)
# Числовая точность, два пути
print(Fraction(1, 3))
decimal.getcontext().prec = 2
print(Decimal('1') / Decimal('3'))
print(1 / 3 + 6 / 12)
print(Fraction(1, 3) + Fraction(6, 12))
print(decimal.Decimal(str(1/3)) + decimal.Decimal(str(6/12)))
print(1000 / 1234567890)
print(Fraction(1000, 1234567890)) # Значительно проще!
print('-' * 10)
# Преобразование дробей и разнородные типы
print((2.5).as_integer_ratio()) # Метод объекта с плавающей точкой
f = 2.5
z = Fraction(*f.as_integer_ratio()) # Преобразует объект с плавающей точкой в дробь:
                                    # два аргумента То же, что и Fraction (5, 2)
print(z)
print(x)  # х из предыдущего взаимодействия
print(x + z)  # 5/2 + 1/3 = 15/6 + 2/6
print(float(x)) # Преобразует дробь в объект с плавающей точкой
print(float(z))
print(float(x + z))
print(17 / 6)
print(Fraction.from_float(1.75))
print(Fraction(*(1.75).as_integer_ratio()))
print('-' * 20)
# в выражениях разрешено смешивать некоторые типы
print(x)
print(x + 2) # Объект дроби + объект целого -> объект дроби
print(x + 2.0) # Объект дроби + объект с плавающей точкой -> объект с плавающей точкой
print(x + (1. / 3))
print(x + (4. / 3))
print(x + Fraction(4, 3)) # Объект дроби + объект дроби -> объект дроби
print(4.0 / 3)
print((4.0 / 3).as_integer_ratio()) # Точность теряется из-за числа с плавающей точкой
print(x)
a = x + Fraction(*(4.0 / 3).as_integer_ratio())
print(a)
print(22517998136852479/13510798882111488) #5/3 (или близко!)
print(a.limit_denominator(10)) # Упростить до ближайшей дроби
print('-' * 10)
''' Множества — неупорядоченная коллекция уникальных и неизменяемых объектов, которая
поддерживает операции, соответствующие математической теории множеств.'''
a = set([1, 2, 3, 4])   # Вызов встроенной функции
b = {1, 2, 3, 4}        # Более новые литералы множеств
print(a , b, a == b)    # Формы записи a и b идентичны
print(set([1, 2, 3, 4]))   # Встроенная функция
print(set('spam'))   # Добавить все элементы из итерируемого объекта
print({1, 2, 3, 4})   # Литералы множеств:
S = {'s', 'p', 'a', 'm'}
S.add('alot') # Методы работают, как и ранее
print(S)
S1 = {1, 2, 3, 4}
print(S1 & {1,3}) # Пересечение
print({1, 5, 3, 6} | S1) # Объединение
print(S1 - {1, 3, 4}) # Разность
print(S1 > {1, 3}) # Надмножество
print(S1 - {1, 2, 3, 4}) # Пустые множества выводятся по-другому set()
print(type(set()))
print(type({})) # Поскольку {} — пустой словарь
S = set() # Инициализация пустого множества
S.add(1.23)
print(S)
print({1, 2, 3} | {3, 4})
# print({1, 2, 3} | [3, 4]) Ошибка типа: неподдерживаемые типы операндов для | : set и list
print({1, 2, 3}.union({3, 4}))
print({1, 2, 3}.union([3, 4]))
print({1, 2, 3}.union(set([3, 4])))
print({1, 2, 3}.intersection({1, 3, 5}))
print({1, 2, 3}.issubset(range(-5, 5)))
# Ограничение неизменяемости и фиксированные множества
# списки и словари не могут встраиваться во множества
print(S)
S.add((1, 2, 3)) # Списки и словари не допускаются, но кортежи разрешены
print(S)
print(S | {(4, 5, 6), (1, 2, 3)})  # Объединение: тоже, что и S. union (. . .)
print((1, 2, 3) in S)  # Членство: по полным значениям
print((1, 4, 3) in S)
print('-' * 20)
#Включения множеств
# “предоставить новое множество, содержащее квадраты х для каждого х в списке”.
print({x ** 2 for x in [1, 2, 3, 4]})  # Включение множества
print({x for x in 'spam'}) # То же, что и set (’spam ')
print({c * 4 for c in 'spam'}) # Множество накопленных результатов выражения
print({c * 4 for c in 'spamham'})
S = {c * 4 for c in 'spam'}
print(S)
print(S | {'mmmm', 'xxxx'})
print(S & {'mmmm', 'xxxx'})
'''Множества допускается использовать для фильтрации дубликатов из коллекций.Коллекцию 
нужно лишь преобразовать во множество и затем выполнить обратное преобразование'''
L = [1, 2, 1, 3, 2, 4, 5]
print(L,'\n',set(L))
L = list(set(L))   # Удаление дубликатов
print(L)
print(list(set(['yy', 'xx', 'cc', 'aa', 'dd', 'aa'])))
'''Множества можно также применять для выделения различий в списках, строках и других 
итерируемых объектах (их необходимо просто преобразовать во множества и получить разность)'''
print(set([1, 3, 5, 7]) - set([1, 2, 4, 5, 6])) # Найти различия в списках
print(set('abcdefg') - set('abdghij')) # Найти различия в строках
print(set('spam') - set(['h', 'a', 'm'])) # Найти различия, разнородные типы
print(set(dir(bytes)) - set(dir(bytearray))) # В bytes , но не в bytearray
print(set(dir(int)) - set(dir(float))) # Разница в методах int и float
'''Множества также можно использовать для выполнения проверок на равенство, ней­
тральное к порядку, за счет предварительного преобразования во множество, потому
что порядок в нем не имеет значения'''
L1, L2 = [1, 2, 3, 4, 5], [5, 4, 2, 1, 3]
print(L1 == L2)   # В последовательностях порядок имеет значение
print(set(L1) == set(L2))   # Проверка на равенство, нейтральное к порядку
print(sorted(L1) == sorted(L2)) # Похожая проверка, но результаты упорядочены
print('spam' == 'asmp', set('spam') == set('asmp'), sorted('spam') == sorted('asmp'))
'''Множества также можно использовать для отслеживания того, где вы уже были, при 
обходе графа или другой циклической структуры.В заключение отметим, что множества 
удобны и в ситуации, когда приходится иметь дело с крупными наборами данных 
(например, результатами запросов к базам данных)'''
engineers = {'bob', 'sue', 'ann', 'vic'}
managers = {'tom', 'sue'}
print('bob' in engineers) # Является ли сотрудник bob инженером (engineer) ?
print(engineers & managers) # Кто одновременно инженер и менеджер (manager) ?
print(engineers | managers) # Все сотрудники в обеих категориях
print(engineers - managers) # Инженеры, не являющиеся менеджерами
print(managers - engineers) # Менеджеры, не являющиеся инженерами
print(engineers > managers) # Все ли менеджеры - инженеры? (надмножество)
print({'bob', 'sue'} < engineers)  # Оба ли сотрудника - инженеры? (подмножество)
print((engineers | managers) > managers) # Все сотрудники - надмножество менеджеров?
print(engineers ^ managers) # Кто находится в одной категории, но не в обеих?
print((engineers | managers) - (engineers ^ managers)) # Пересечение!
