# Списки и словари
# Списки
'''
Они являются упорядоченными коллекциями произвольных объектов
Они поддерживают доступ по смещению
Они имеют переменную длину, разнородны и допускают произвольно глубокое вложение
Они относятся к категории "изменяемая последовательность"
Они представляют собой массивы ссылок на объекты

L = [] Пустой список
L = [123, 'abc', 1.23, {}] Четыре элемента: индексы 0..3
L = ['Bob', 40.0, ['dev', 'mgr']] Вложенные подсписки
L = list('spam') Список элементов итерируемого объекта
L = list(range(-4, 4)) список последовательных целых чисел
L[i] Индекс
L[i][j] индекс индекса
L[i:j] срез
len(L)  длина
LI + L2 Конкатенация
L * 3  повторение
for х in L: print (х) -Итерация
3 in L - членство
L. append(4)
L.extend([5,6,7])
L.insert(i, X) Методы: увеличение
L.index(X) Методы: поиск
L.count(X)
L.sort()
L.reverse()
L.copy()
L.clear() Методы: сортировка, обращение, копирование
(Python 3.3+), очистка (Python 3.3+)
L.pop(i)
L. remove (X)
del L[i]
del L[i:j]
L[i:j] = [] Методы, операторы: уменьшение
L[i] = 3
L[i:j] = [4,5,6] Присваивание по индексу, присваивание по срезу
'''
print(type([]))
print(dir(list))
print(dir([]))
L = list('spam')
print(L)
print('-' * 20)
# Списки в действии
# Базовые списковые операции
print(len([1, 2, 3])) # Длина
print([1, 2, 3] + [4, 5, 6]) # Конкатенация
print(['Ni!'] * 4)  # Повторение
print(str([1, 2]) + "34") # То же, что и "[1, 2]" + "34"
print([1, 2] + list("34")) # То же, что и [1, 2] + ["3", "4"]
# Итерация по спискам и списковые включения
print(3 in [1, 2, 3])  # Членство
for x in [1, 2, 3]:  # Итерация
    print(x, end=' ')
print([c * 4 for c in 'SPAM']) # Списковые включения
res = []
for с in 'SPAM': # Эквивалент спискового включения
    res.append(с * 4)
print(res)
print(list(map(abs, [-1, -2, 0, 1, 2]))) # Отображение функции по всей последовательности
# Индексация, нарезание и матрицы
L = [ 'spam', 'Spam', 'SPAM!']
print(L[2])# Смещения начинаются с нуля
print(L[-2]) # Отрицательные смещения отсчитываются справа
print(L[1:]) # Нарезание извлекает сегменты
# базовый двумерный массив 3x3
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(matrix)
print(matrix[1])
print(matrix[1][1])
print(matrix[2][0])
# Изменение списков на месте
#Присваивания по индексам и срезам
L = ['spam', 'Spam', 'SPAM!']
L[1] = 'eggs' # Присваивание по индексу
print(L)
L[0:2] = ['eat', 'more'] # Присваивание по срезу: удаление + вставка
print(L) # Заменяет элементы 0, 1
L = [0, 1, 2, 3, 4, 5]
L[2:5] = L[3:6] # вставляемое значение извлекается до того, как слева происходит удаление
print(L)
print('=' * 20)
L = [1, 2, 3]
print(L)
L[1:2] = [4, 5] # Замена/вставка 4, 5 вместо 2
print(L)
L[1:1] = [6, 7] # Вставка (ничего не заменяет)
print(L)
L[1:2] = [] # Удаление (ничего не вставляет)
print(L)
print('=' * 20)
L = [1]
L[:0] = [2, 3, 4] # Вставить все на место :0, пустой срез в начале
print(L)
L[len(L):] = [5, 6, 7] # Вставить все на место len(L) :, пустой срез в конце
print(L)
L.extend([8, 9, 10]) # Вставить все в конце, именованный метод
print(L)
print('=' * 20)
# Вызовы списковых методов
L = ['eat', 'more', 'SPAM!']
L.append('please')
print(L)
L.sort() # Сортировка элементов списка (' S1 < 'е')
print(L)
print('=' * 20)
# Дополнительные сведения о сортировке списков
L = ['abc', 'ABD', 'aBe']
print(L)
L.sort() # Сортировка со смешанным регистром символов
print(L)
L = ['abc', 'ABD', 'aBe']
L.sort(key=str.lower) # Приведение к нижнему регистру
print(L)
L = ['abc', 'ABD', 'aBe']
L.sort(key=str.lower, reverse=True) # Изменение порядка сортировки
print(L)
L = ['abc', 'ABD', 'аВе']
print(sorted(L, key=str.lower, reverse=True)) # Встроенная функция сортировки
L = ['abc', 'ABD', 'аВе']
print(sorted([x.lower() for x in L], reverse=True)) # Предварительно трансформирует
                                                     # элементы: отличается!
# Другие распространенные списковые методы
L = [1, 2]
L.extend([3, 4, 5]) # Добавление множества элементов в конец (подобно + на месте)
print(L)
print(L.pop()) # # Удаление и возврат последнего элемента (по умолчанию: -1)
print(L)
L.reverse() # Метод обращения списка на месте
print(L)
print(list(reversed(L))) # Встроенная функция обращения списка с результатом (итератор)
L = []
L.append(1) # Затолкнуть в стек
L.append(2)
print(L)
L.pop() # Вытолкнуть из стека
print(L)
L = ['spam', 'eggs', 'ham']
print(L)
print(L.index('eggs')) # Индекс объекта (поиск)
L.insert(1, 'toast')  # Вставка в позицию
print(L)
L.remove('eggs') # Удаление по значению
print(L)
L.pop(1) # Удаление по позиции
print(L)
print(L.count('spam')) # Количество вхождений
# Другие распространенные списковые операции
L = ['spam', 'eggs', 'ham', 'toast']
print(L)
del L[0] # Удаление одного элемента
print(L)
del L[1:] # Удаление целой секции, no же, что и L[1: ] = []
print(L)
'''можно также удалять секцию списка, присваивая срезу пустой
список (L [i:j] = [])'''
L = ['Already', 'got', 'one']
L[1:] = []
print(L)
L[0] = []
print(L)
print('=' * 20)
# Словари
'''
Они поддерживают доступ по ключу, а не по смещению
Они являются неупорядоченными коллекциями произвольных объектов
Они имеют переменную длину, разнородны и допускают произвольно глубокое вложение
Они относятся к категории “изменяемое отображение”
Они представляют собой таблицы ссылок на объекты (хеш-таблицы)
'''

'''
D = {} Пустой словарь
D= {'name': 'Bob', 'age': 40} Двухэлементный словарь
E = {'cto': {'name': 'Bob', 'age': 40}} Вложение
D = dict(name='Bob', age=40) Альтернативные методики создания:
D = dict([('name', 'Bob'), ('age', 40)]) ключевые слова, пары “ключ/значение”, упако-
ванные пары “ключ/значение”, списки ключей
D = dict(zip(keyslist, valueslist))
D = dict.fromkeys (['name', 'age'])

D['name'] - Индексирование по ключу
Е['cto']['age'] 
'age' in D - Членство: проверка присутствия ключа
D.keys ()  - Методы: все ключи,
D.values() - все значения
D.items() - все кортежи ключ+значение,
D.copy() - копирование (верхнего уровня)
D.clear() - очистка (удаление всех элементов)
D.update(D2) - объединение по ключам 
D.get(key, default?) - извлечение по ключу; если отсутствует, тогда
                       возвратить стандартное значение (или None)
D.pop(key, default?) - удаление по ключу; если отсутствует, тогда
                    возвратить стандартное значение (или ошибку)
D.setdefault(key, default?) - установка по ключу; если отсутствует, тогда ус­
                               тановить в стандартное значение (или None),
D.popitem() - удаление/возвращение любой пары (ключ, зна­
чение); и т.д.
len(D) Длина: количество сохраненных элементов
D[key] = 42 Добавление ключей, изменение значений, связанных с ключами
del D[key] Удаление элементов по ключу
list(D.keys())
DI.keys() & D2.keys() Словарные представления (Python З.Х)
'''
# завершенный список операций
print(type({}))
print(dir(dict))
print(dir({}))
d = {'Russia': 'Moscow'}
print(d['Russia'])
# Базовые словарные операции
D = {'spam':2, 'ham':1, 'eggs':3} # Создание словаря
print(D['spam']) # Извлечение значения по ключу
print(D)
print(len(D)) # Количество элементов в словаре
print('ham' in D) # Проверка членства
print(list(D.keys())) # Создание нового списка ключей в D
print(D.keys()) # выводит список ключей
print('-' * 10)
# Изменение словарей на месте
print(D)
D['ham'] = ['grill', 'bake', 'fry'] # Изменение элемента (значение - список)
print(D)
del D['eggs']
print(D)
D['brunch'] = 'Bacon'
print(D)
# Дополнительные словарные методы
D = {'spam':2, 'ham':1, 'eggs':3}
print(list(D.values())) # возвращает  значения словаря
print(list(D.items())) # возвращает кортежи с парами (ключ, значение)
print(D.get('spam'))  # Проверяет наличие ключа: Ключ присутствует
print(D.get('toast')) # Проверяет наличие ключа: Ключ отсутствует
print(D.get('toast', 88))
print(D)
D2 = {'toast':4, 'muffin':5}
print(D2)
D.update(D2) # Объединение словарей
print(D)
D.pop('muffin') # удаляет ключ из словаря
print(D)
D.pop('toast')
print(D)
# Пример: база данных о фильмах
table = {'1975': 'Holy Grail',
         '1979': 'Life of Brian',
         '1983': 'The Meaning of Life'} # Ключ: Значение
year = '1983'
movie = table[year] # словарь [Ключ] => Значение
print(movie)
for year in table: # To же, что и for year in table.keys()
    print(year, '\t', table[year])

# Обзор: отображение значений на ключи
table = {'Holy Grail': '1975',
         'Life of Brian': '1979',
         'The Meaning of Life': '1983'} # Ключ=>Значение (название=>год)
print(table['Holy Grail'])
print(list(table.items())) # Значение=>Ключ (год=>название)
print([title for (title, year) in table.items() if year == '1975'])
k = 'Holy Grail'
print(table[k]) # Ключ=>Значение (нормальное использование)
v = '1975'
print([key for (key, value) in table.items() if value == v]) # Значение=>Ключ
print([key for key in table.keys() if table[key] == v])  # To же самое
print('=' * 10)
# Замечания по использованию словарей
'''в качестве ключей  допускается применять любые неизменяемые объекты.
Строки, целые числа, кортежи (даты и IP-адреса)'''
# Использование словарей для имитации гибких списков: целочисленные ключи
D = {}
D[99] = 'spam'
print(D)
table = {1975: 'Holy Grail',
         1979: 'Life of Brian',
         1983: 'The Meaning of Life'} # Ключи являются целыми числами, не строками
print(table[1975])
print(list(table.items()))
print('-' * 20)
# Использование словарей для разреженных структур данных: ключи в форме кортежей
'''Здесь мы используем словарь для представления трехмерного массива, который
 пуст за исключением двух позиций (2,3,4) и (7,8,9)'''
matrix = {}
matrix[(2, 3, 4)] = 88
matrix[(7, 8, 9)] = 99
x = 2; y = 3; z = 4  # ; отделяет операторы: см. главу 10 или x, y, z = 2, 3, 4
print(matrix[(x, y, z)])
print(matrix)
print(matrix.get((2, 3, 6))) # узнаем, есть ли что то в этой ячейке
# print(matrix[(2, 3, 6)]) - выдаст ошибку - нет такого ключа

# трехмерный массив
ar=[[[0 for i in range(3)] for j in range(3)] for k in range(3)]
print(ar)
print('-' * 10)
# Избегание ошибок, связанных с отсутствующими ключами
'''1) заранее проверять ключи в операторах if'''
if (2, 3, 6) in matrix:
    print(matrix[(2, 3, 6)])
else:
    print(0)
'''2)  Попытка индексации.Перехват и восстановление'''
try:
    print(matrix[(2, 3, 6)])
except KeyError:
    print(0)
'''3) метод get. Существует: извлечь и возвратить, Не существует: 
использовать стандартный аргумент'''
print(matrix.get((2, 3, 4), 0))
print(matrix.get((2, 3, 6), 0))
print(matrix.get((2, 3, 6), 'No'))
print('-' * 20)
# Вложение словарей
'''словари — это один из многих способов описания свойств элемента
в предметной области программы. В следующем примере заполняется словарь, 
описывающий гипотетическое лицо,путем присваивания по новым ключам со временем:'''
rec = {}
rec['name'] = 'Bob'
rec['age'] = 4.5
rec['jobs'] = 'developer/manager'
print(rec['name'], rec)
rec = {'name': 'Bob' ,
       'jobs': ['developer', 'manager'],
       'web': 'www.bobs.org/~Bob',
       'home': {'state': 'Overworked', 'zip': 12345}}
print(rec['name'])
print(rec['jobs'])
print(rec['jobs'][1])
print(rec['home']['zip'])

db = []
db.append(rec)     # "База данных" в форме списка
db.append('other')
db[0]['jobs']
print(db)
db = {}           # "База данных" в форме словаря
db['bob'] = rec
db['sue'] = 'other'
db['bob']['jobs']
print(db)
print('-' * 10)
# Другие способы создания словарей (4 вида)
'''• Первая форма удобна, если вы в состоянии записать словарь заранее.'''
d = {'name': 'Bob', 'age': 40} # Традиционное литеральное выражение
'''• Вторая форма используется, когда словарь необходимо создавать на лету по од­
ному полю за раз.'''
D = {} # Динамическое присваивание по ключам
D['name'] = 'Bob'
D['age' ] = 40
'''• Третья форма сопряжена с меньшим объемом набора, чем первая, но требует,
чтобы все ключи были строками.'''
dict(name='Bob', age=40) # Форма dict с ключевыми аргументами
'''• Четвертая форма применяется, если ключи и значения нужно накапливать как
последовательности во время выполнения.'''
dict([('name', 'Bob'), ('age', 40)]) # Форма diet с кортежами " ключ/значение"
'''dict(zip(keyslist, valueslist)) # Форма с упакованными кортежами "ключ/значение"'''
'''При условии, что значения, ассоциированные со всеми ключами, первоначально
одинаковы, словарь можно также создать с помощью следующей специальной фор­
мы — просто передавая список ключей и начальную величину для всех значений'''
d = dict.fromkeys(['a', 'b'], 0)
print(d)
# Что потребует внимания: словари или списки
'''
данные словарей часто несут больше смысла для людей, читающих код
Имена выразительее чисел
'''
D = {}
D['statel'] = True
print('statel' in D) # Словарь посещенных состояний
S = set()
S.add('statel')
print('statel' in S) # To же самое, но с использованием множества
# Включения словарей
print(list(zip(['a', 'b', 'c'], [1, 2, 3]))) # Упаковка вместе ключей и значений
print(dict(zip(['a', 'b', 'c'], [1, 2, 3])))  # Создание словаря из результата zip
D = {k: v for (k, v) in zip (['а', 'b', 'с'], [1, 2, 3])}
print(D)
D = {x: x ** 2 for x in [1, 2, 3, 4]} # Или range (1, 5)
print(D)
D = {с: с * 4 for с in 'SPAM'} # Проход в цикле по любому итерируемому объекту
print(D)
D = {c.lower(): c + '!' for c in ['SPAM', 'EGGS', 'НАМ']}
print(D)
print('-' * 20)
D = dict.fromkeys ([' а ' , 'b', 'с'], 0) # Инициализация словаря из ключей
print(D)
D = {к: 0 for к in [ 'а' , 'b' , 'С' ]} # То же самое, но посредством включения
print(D)
D = dict.fromkeys('spam') # Другие итерируемые объекты, стандартное значение  None
print(D)
D = {k: None for k in 'spam' }
print(D)
print('-' * 10)
# Словарные представления
d = dict(a=1, b=2, c=3)
print(d)
k = d.keys()
print(k)
print(list(k))
v = d.values()
print(v)
print(list(v))
i = d.items()
print(i)
print(list(i))
print(list(k)[0])
# Словарные представления и множества
print(k, v)
print(k | {'x': 4}) # Представления ключей (и некоторых элементов) подобны множествам
D = {'a': 1, 'b': 2, 'c': 3}
print(D.keys() & D.keys()) # Пересечение представлений ключей
print(D.keys () & {'b'}) # Пересечение представления ключей и множества
print(D.keys () & {'b': 1}) # Пересечение представления ключей и словаря
print(D.keys() | {'b', 'c', 'd'}) # Объединение представления ключей и множества
print('-' * 10)
# Сортировка ключей словаря
D = {'c': 3, 'a': 1, 'b': 2}
ks = D.keys()
ks = list(ks) # Преобразовать в список и затем сортировать
ks.sort()
print(ks)
# Или можно вызвать sorted на ключах sorted принимает любой
# итерируемый объект, sorted возвращает свой результат
ks = D.keys()
for key in sorted(ks): print(key, D[key])
# Еще лучше сортировать словарь напрямую
# Итераторы словаря возвращают ключи
for key in sorted(D): print(key, D[key])
print('-' * 20)
'''Проверьте свои знания: контрольные вопросы
1. Назовите два способа построения списка, содержащего пять целочисленных нулей.
2. Назовите два способа построения словаря с двумя ключами, ’ а ’ и ’Ь’, с каж­
дым из которых ассоциировано значение 0.
3. Назовите четыре операции, которые изменяют списковый объект на месте.
4. Назовите четыре операции, которые изменяют словарный объект на месте.
5. Почему вы можете использовать словарь вместо списка?'''
#1
l = [0 for k in range(5)]
l2 = [0, 0, 0, 0, 0]
l3 = [0]*5
print(l, l2, l3,e)
#2
d = {'a': 0, 'b': 0}
d2 = {}
d2['a'] = 0
d2['b'] = 0
d3 = dict.fromkeys(('a', 'b'), 0)
print(d, d2, d3)
#3
l[0] = 1
l[1:2] = [2]
l.insert(2,3)
l.pop()
l[3:3] = [4]
l[4:5] = []
print(l, end=' ')
print('append, pop, extend, insert, sort, revers, remove')
#4
d['key'] = 'value'
del d['a']
d.pop('b')
d.update(d2)
print(d)
#5
print('''
данные словарей часто несут больше смысла для людей, читающих код
Имена выразительее чисел''')