# Кратко о динамической типизации
# Случай отсутствия операторов объявления
# Переменные, объекты и ссылки
# Типы обитают в объектах, не в переменных
a = 3 # Переменная является целым числом
a = 'spam' # Теперь она стала строкой
a = 1.23 # А теперь - числом с плавающей точкой
'''Имена не имеют типов, мы лишь изменяем 'а' для ссылки на другие объекты.Фактически 
мы можем сказать о переменной, что она ссылается на определенный  объект в конкретный 
момент времени.Так как объектам известны свои типы, переменным знать их вовсе не обязательно'''
# Объекты подвергаются сборке мусора
x = 42
x = 'shrubbery' # Освободить память, занимаемую 42 (если нет ссылок где-то еще)
x = 3.1415  # Освободить память, занимаемую 'shrubbery'
x = [1, 2, 3] # Освободить память, занимаемую 3.1415
'''Каждый раз, когда 'х' присваивается новый объект, Python освобождает память, заня­
тую предыдущим объектом, т.е. область памяти объекта автоматически попадает в пул
свободного пространства, чтобы быть задействованной каким-то будущим объектом.Внутренне 
Python  совершает такой ловкий трюк за счет ведения в каждом объекте счетчика, который 
отслеживает количество ссылок, в текущий момент указывающих на объект.'''
# Разделяемые ссылки это когда множество имен ссылается на один и тот же объект
a = 3 # 'a' ссылается на объект '3'
b = a    # 'b' ссылается на объект '3'
a = 'spam' # 'a' ссылается на объект 'spam', 'b' на '3'

a = 3 # 'a' ссылается на объект '3'
b = a # 'b' ссылается на объект '3'
a = a + 2  # 'a' ссылается на объект '3', 'b' на '5'

# Разделяемые ссылки и изменения на месте
'''Изменяемые типы (списки, словари и множества) - объекты и операции, ко­
торые вносят в объекты изменения на месте'''
L1 = [2, 3, 4] # Изменяемый объект
L2 = L1 # Создает ссылку на тот же самый объект
print(L1, L2)
L1[0] = 24 # Изменение на месте
print(L1) # L1 отличается
print(L2) # Но отличается и L2!
L1.append(5)
print(L1, L2)
'''Такое поведение характерно только для изменяемых объектов, которые поддержи­
вают изменения на месте, и обычно является желательным, но вы обязаны знать, как
оно работает, и ожидать его. Если вас не устраивает это поведение, тогда можете 
запросить у Python копирование объектов вместо ссылки на них.'''
L1 = [2, 3, 4]
L2 = L1[:] # Создать копию L1 (0.039 сек), нарезание работает только для списков
L3 = list(L1) # Создать копию L1  (0,075 сек)
import copy
L4 = copy.copy(L1) # Создать копию L1 (0.186 сек)
print(L1, L2, L3, L4)
L1.append(5)
print(L1, L2, L3, L4) # L2, L3, L4 не изменяется
'''Здесь изменение, внесенное через L1, не влияет на L2, поскольку L2 ссылается на
копию, а не на оригинал объекта, на который ссылается L1; т.е. две переменные ука­
зывают на разные участки памяти.'''
Y = 0
X = copy.copy(Y) # Создать "поверхностную" копию верхнего уровня любого объекта Y
X = copy.deepcopy(Y) # Создать глубокую копию любого объекта Y: копировать все вложенные части

# Разделяемые ссылки и равенство
L = [1, 2, 3]
M = L   # М и L ссылаются на один и тот же объект
print(L == M)  # Одинаковые значения
print(L is M) # Одинаковые объекты
'''Первый прием, операция ==, предусматривает проверку, имеют ли два ссылаемых
объекта одинаковые значения; такой метод почти всегда используется для проверок на
предмет равенства в Python. Второй прием, операция is, проверяет идентичность —
она возвращает True, только если оба имени указывают на точно тот же самый объ­
ект, поэтому операция is является гораздо более строгой формой проверки равенс­
тва и редко применяется в большинстве программ.
На самом деле операция is просто сравнивает указатели, которые реализуют ссыл­
ки, и при необходимости служит способом обнаружения разделяемых ссылок в коде.
Она возвращает False, если имена указывают на эквивалентные, но разные объекты,
как в случае выполнения двух разных литеральных выражений:'''
L = [1, 2, 3]
M = [1, 2, 3]   # М и L ссылаются на разные объекты
print(L == M)  # Одинаковые значения
print(L is M) # Разные объекты
X = 42
Y = 42  # Должны быть двумя разными объектами
print(X == Y)
print(X is Y) # Как бы то ни было, тот же самый объект: кеширование в действии!
'''поскольку небольшие целые числа и строки кешируются и используются повторно, 
операция 'is' сообщает о том, что они ссылаются на тот же самый одиночный объект.'''
import sys
print(sys.getrefcount(1)) # 908 указателя на этот разделяемый участок памяти
print(sys.getrefcount(Y))

# Динамическая типизация вездесуща
