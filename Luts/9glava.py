# Кортежи, файлы и все остальное
# Кортежи
'''
- Они являются упорядоченными коллекциями произвольных объектов
- Они поддерживают доступ по смещению
- Они относятся к категории “неизменяемая последовательность"
- Они имеют фиксированную длину, разнородны и допускают произвольно глубокое вложение
- Они представляют собой массивы ссылок на объекты

() - Пустой кортеж
т = (О,) - Одноэлементный кортеж (не выражение)
Т = (0, 'Ni', 1.2, 3) -Четырехэлементный кортеж
Т = О, 'Ni', 1.2, 3 - Еще один четырехэлементный кортеж
                    (такой же, как в предыдущей строке)
Т = ('Bob', ('dev', 'mgr')) - Вложенные кортежи
Т = tuple('spam') - Кортеж из элементов итерируемого объекта
T[i]     - Индекс, индекс индекса, срез, длина
T[i][j]
T[i:j]
len(T)
T1 + T2 - Конкатенация, повторение
T * 3
for x in T: print(x) - Итерация,членство
'spam' in T
[x ** 2 for x in T]
T.index('Ni') - поиск
T.count('Ni') - подсчет
'''
tuple = (1, 1, [1])
tuple[2].append('spam')
tuple[2].append(42)
print(tuple)
# Кортежи в действии
print((1, 2) + (3, 4)) # Конкатенация
print((1, 2) * 4) # Повторение
T = (1, 2, 3, 4)
print(T[0], T[1:3]) # Индексация, нарезание
x = (40) # Целое число!
print(x)
y = (40,) # Кортеж, содержащий целое число
print(y)
a = 'spam'
print(a,''.join(sorted(a)))
# Преобразования, методы и неизменяемость
t = (11, 8, 3, 5)
print(t, sorted(t))
tmp = list(t)
tmp.sort()
print(tmp)
print('-' * 10)
T = ('cc', 'aa', 'dd', 'bb')
tmp = list(T) # Создание списка из элементов кортежа
tmp.sort() # Сортировка списка
# T = tuple(tmp) # Создание кортежа из элементов списка
print(T, tmp)
print(sorted(T)) # Либо использование встроенной функции sorted, и экономия двух шагов
t = (1, 2, 3, 4, 5)
L = [х + 20 for х in t]
print(t,'\n', L)
t = (1, 2, 3, 2, 4, 2)
print(t.index(2)) # Смещение первого появления элемента 2
print(t.index(2,2)) # Смещение появления элемента 2 после смещения 2
print(t.count(2)) # Сколько всего элементов 2?
t = (1, [2, 3] , 4)
t[1][0] = 'spam' # Работает: изменяемые объекты внутри кортежа можно модифицировать
print(t)
# Для чего используются списки и кортежи?
'''неизменяемость кортежей обеспечивает определенную степень целостности'''
# Снова о записях: именованные кортежи
bob = ('Bob', 40.5, ['dev', 'mgr'])  # Запись в виде кортежа
print(bob)
print(bob[0], bob[2]) # Доступ по позиции
bob = dict(name='Bob', age=40.5, jobs=['dev','mgr']) # Запись в виде словаря
print(bob)
print(bob['name'], bob['jobs'])  # Доступ по ключу
#tuple(bob.values()) # Преобразование значений в кортеж
print(list(bob.items())) # Преобразование элементов в список кортежей

from collections import namedtuple # Импортирование типа расширения
Rec = namedtuple('Rec', ['name', 'age', 'jobs']) # Создание производного класса
bob = Rec('Bob', age=40.5, jobs=['dev', 'mgr'])  # Запись в виде именованного кортежа
print(bob)
print(bob[0], bob[2]) # Доступ по позиции
print(bob.name, bob.jobs) # Доступ по атрибуту
o = bob._asdict() #Форма, похожая на словарь
print(o)
print(o['name'], o['jobs']) # Доступ также и по ключу
bob = Rec('Bob', 40.5, ['dev', 'mgr']) # Для кортежей и именованных кортежей
name, age, jobs = bob # Присваивание кортежей
print(bob)
print(name, jobs)
for x in bob: print(x) # Итерационный контекст
print('=' * 20)

# Файлы - именованные ячейки хранилища на компьютере, управляемые операционной системой.
#Это основной тип
'''
output = open(r'С:\spam', 'w') Создает выходной файл ('w' означает write — запись)
input = open('data', 'r') Создает входной файл ('r' означает read — чтение)
input = open('data') То же, что и в предыдущей строке ('r' выбирается по умолчанию)
aString = input.read() Читает целый файл в одиночную строку
aString = input.read(N) Читает до N следующих символов (или байтов) в строку
aString = input.readline() Читает следующую строку файла (включая символ новой строки \n) в строку
aList = input.readline() Читает целый файл в список строк (с символами \n)
output.write(aString) Записывает строку символов (или байтов) в файл
output.writelines(aList) Записывает все строки из списка в файл
output.close() Вручную закрывает файл (это делается автоматически, когда файловый объект 
               подвергается сборке мусора)
output.flush() Сбрасывает буфер вывода на диск, не закрывая файл
anyFile.seek(N) Изменяет позицию на N для следующей операции
for line in open('data'): Файловые итераторы, читающие строку за строкой
open('f.txt', encoding='latin-1') Текстовые файлы Unicode в Python З.Х (строки str)
open('f.bin', 'rb') Байтовые файлы в Python З.Х (строки bytes)
'''
# Открытие файлов
# afile = open(имя__файла, режим)
# afile.метод()

# Использование файлов
'''
Файловые итераторы лучше всего подходят для чтения строк
Содержимое является строками, а не объектами
Файлы буферизируются и поддерживают позиционирование
Вызов метода close часто необязателен: автоматическое закрытие при сборке мусора
'''
# Файлы в действии
myfile = open('myfile.txt', 'w') # Открытие файла для текстового вывода: создание/очистка
myfile.write('hello text file\n') # Запись строки текста: строковый объект
myfile.write('goodbye text file\n')
myfile.close() # Сброс выходных буферов на диск
myfile = open('myfile.txt') # Открытие файла для текстового ввода: 'r' принимается по умолчанию
print(myfile.readline()) # Чтение строк
print(myfile.readline()) # Чтение строк
print(myfile.readline()) # Пустая строка: конец файла
print('-' * 20)
open('myfile.txt').read() # Чтение сразу всего файла в строковый объект
print(open('myfile.txt').read()) # Дружественное к пользователю отображение
print('-' * 20)
for line in open('myfile.txt'): # Использование файловых итераторов, а не чтения
    print(line, end='')
print('-' * 20)

# Кратко о текстовых и двоичных файлах
data = open('data.bin', 'rb').read() # Открытие двоичного файла: rb = чтение двоичный
print(data)  # Строка bytes хранит двоичные данные
print(data[4:8]) # Действует подобно строкам
#print(data[4:8][0]) # Но на самом деле является 8-битными целыми числами
#print(bin(data[4:8][0]))
print('-' * 20)

# Хранение объектов Python в файлах: преобразования
X, Y, Z = 43, 44, 45 # Собственные объекты Python
S = 'Spam'           # Для сохранения в файле обязаны быть строками
D = {'a': 1, 'b': 2}
L = [1, 2, 3]
F = open('datafile.txt', 'w') # Создание выходного текстового файла
F.write(S + '\n')  # Завершение строк символом \n
F.write('%s,%s,%s\n' % (X, Y, Z)) # Преобразование чисел в строки
F.write(str(X) + ' ' + str(Y) + ' ' + str(Z) + '\n')
F.write(str(L) + '$' + str(D) + '\n') # Преобразование и разделение посредством $
F.close()
chars = open('datafile.txt').read() # Отображение неформатированной строки
print(chars) # Дружественное к пользователю отображение
print('-' * 20)

F = open('datafile.txt') # Открытие файла
line = F.readline() # Чтение одной строки
print(line) # Чтение одной строки
line.rstrip() # Удаление символа конца строки
print(line)
line = F.readline() # Чтение следующей строки из файла
print(line) # Строковый объект
parts = line.split(',') # Разбиение (разбор) по запятым
print(parts)
print(int(parts[0])) # Преобразование строки в целое число
numbers = [int(i) for i in parts] # Преобразование всего списка за раз
print(numbers)
print('-' * 20)
line = F.readline() # Чтение следующей строки из файла
line = F.readline() # Чтение следующей строки из файла
print(line)
parts = line.split('$')
print(parts)
eval(parts[0]) # Преобразование в объект любого типа
print(parts[0])
print(type(eval(parts[0])))
print(type(eval(parts[1])))
objects = [eval(i) for i in parts]
print(objects)
'''Поскольку конечным результатом всего разбора и преобразования является список
нормальных объектов Python, а не строк, теперь мы можем применять к ним списко­
вые и словарные операции в своем сценарии.'''
print('-' * 20)
file = open('datafile.txt')
line = file.readline()
line = file.readline()
print(line)
parts = line.split(',')
n = [eval(i) for i in parts]
print(parts, n)
print(type(parts[0]))
print(type(eval(parts[0])))
print('-' * 20)

# Хранение собственных объектов Python: модуль pickle
# Модуль pickle - позволяет сохранить почти любой объект Python в файл напрямую, не
# требуя преобразования в строку.Он похож на крайне универсальную утилиту форматиро­
# вания и разбора данных.
D = {'a': 1, 'b': 2}
F = open('datafile.pkl', 'wb')
import pickle
pickle.dump(D, F) # Сохранение любого объекта в файл с помощью pickle
F.close()

F = open('datafile.pkl', 'rb')
E = pickle.load(F) # Загрузка любого объекта из файла
print(E)
print(open('datafile.pkl', 'rb').read()) # так выглят наш словарь в файле (байтстрока)
print('-' * 20)

# Хранение объектов Python в формате JSON
name = dict(first = 'Bob', last = 'Smith')
rec = dict(name = name, job = ['dev', 'mgr'], age = 40.5)
print(1, rec)
import json
s = json.dumps(rec)
print(s)
o = json.loads(s)
print(o)
print(o == rec)
json.dump(rec, fp = open('testjson.txt', 'w'), indent=4)
print(open('testjson.txt').read())
n = json.load(open('testjson.txt'))
print(n)
print('-' * 20)
# Хранение упакованных двоичных данных: модуль struct
f = open('data2.bin', 'wb') # Открытие двоичного выходного файла
import struct
data = struct.pack('>i4sh', 7, b'spam', 8) # Создание упакованных двоичных данных
print(data)
f.write(data) # Запись строки байтов
f.close()
f = open('data2.bin', 'rb')
data = f.read() # Получение упакованных двоичных данных
print(data)
values = struct.unpack('>i4sh', data) # Преобразование в объекты Python
print(values)
# Диспетчеры контекстов для файлов
# Другие файловые операции
print('-' * 20)
# Обзор и сводка по основным типам
l = ['abc', [(1, 2), ([3], 4)], 5]
print(l)
print(l[1])
print(l[1][1])
print(l[1][1][0])
print(l[1][1][0][0])
x = [1, 2, 3]
l = ['a', x, 'b'] # Встроенные ссылки на объект X
d = {'x': x, 'y': 2} # Встроенные ссылки на объект X
print(l,'\n', d)
x[1] = 'surprise' # Изменяет все три ссылки!
print(l, '\n', d)
print('-' * 10)
# Убеждаемся, что ссылки на объекты разные, когда делаем копию
a = 5
b = a
print(a, b, id(a), id(b))
v1 = 1024
v2 = v1
print(v1, v2, id(v1), id(v2))
v1 = 2048
print(v1, v2, id(v1), id(v2))
t1 = (1, 2, 3)
t2 = t1
print(t1, t2, id(t1), id(t2))
t1 = (1, 10, 3)
print(t1, t2, id(t1), id(t2))

l = [1, 2, 3]
d = {'a': 1, 'b': 2}
a = l[:] # Вместо А = L (или list (L))
b = d.copy() # Вместо В = D (то же самое для множеств)
print(l, '->', id(l), '\n', a, '->', id(a))
print(d, '->', id(d), '\n', b, '->', id(b))
a[1] = 'Ni'
b['c'] = 'spam'
print(l,d)
print(a,b)

x = [1, 2, 3]
l =['a', x[:], 'b'] # Встраивание копий объекта X
d = {'х': x[:], 'у' :2}

import copy
x = copy.deepcopy(l) # Полная копия объекта Y с произвольно глубоким вложением
print('-' * 10)
# Сравнения, равенство и истинность
L1 = [1, ('а', 3)] # Одинаковые значения, уникальные объекты
L2 = [1, ('а', 3)]
print(L1 == L2, L1 is L2) # Эквивалентны? Тот же самый объект?
S1 = 'spam'
S2 = 'spam'
print(S1 == S2, S1 is S2)
S1 = 'a longer string'
S2 = 'a longer string'
print(S1 == S2, S1 is S2)
L1 = [1, ('а' ,3)]
L2 = [1, ('а' ,2)]
print(L1 < L2, L1 == L2, L1 > L2) # Меньше, равно, больше

# Смысл понятий "истина" и "ложь" в Python

